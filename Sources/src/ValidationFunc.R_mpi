#library(foreach)
#library(doParallel)
library(doMPI)
library(rlist)

HoldoutTest=function(ratdata,allModelRes,testData,src.dir,setup.hpc)
{
  models = testData@Models
  creditAssignment = testData@creditAssignment

  modelNames = as.vector(sapply(creditAssignment, function(x) paste(models, x, sep=".")))

  mat_res = matrix(0, length(modelNames), length(modelNames))
  colnames(mat_res) <- modelNames
  rownames(mat_res) <- modelNames
  

  print(sprintf("models: %s",toString(modelNames)))
  
  
  if(setup.hpc)
  {
    #worker.nodes = mpi.universe.size()-1
    #print(sprintf("worker.nodes=%i",worker.nodes))
    #cl <- makeCluster(30, type='PSOCK',outfile = "")
    
    cl <- startMPIcluster()
    #print(mpi.comm.rank(0))

    #registerDoMPI(cl)
  }
  else
  {
    cl <- makeCluster(3, outfile = "")
    #registerDoParallel(cl)
  }
  
  exportDoMPI(cl, c("src.dir"),envir=environment())
  registerDoMPI(cl)
 
  #cat(sprintf('mpi.universe.size=\n', mpi.universe.size()))
  cat(sprintf('Running validation with %d worker(s)\n', getDoParWorkers()))

  

  initWorkers <-  function() {
     source(paste(src.dir,"ModelClasses.R", sep="/"))
     source(paste(src.dir,"TurnModel.R", sep="/"))
     source(paste(src.dir,"HybridModel1.R", sep="/"))
     source(paste(src.dir,"HybridModel2.R", sep="/"))
     source(paste(src.dir,"HybridModel3.R", sep="/"))
     source(paste(src.dir,"HybridModel4.R", sep="/"))
     source(paste(src.dir,"BaseClasses.R", sep="/"))
     source(paste(src.dir,"exportFunctions.R", sep="/"))
     source(paste(src.dir,"ModelUpdateFunc.R", sep="/"))
     #attach(myEnv, name="sourced_scripts")
   }

  opts <- list(initEnvir=initWorkers)

time1 <-system.time( 
  generatedDataList <-  
   foreach(i=1:length(modelNames), .options.mpi=opts,.packages = c("rlist","DEoptim","dplyr","TTR"),.export=c("testData")) %:%
    foreach(generation=1:3) %dopar%
    {
      model = modelNames[i] 
      modelName = strsplit(model,"\\.")[[1]][1]
      creditAssignment = strsplit(model,"\\.")[[1]][2]
      trueModelData = slot(slot(allModelRes,modelName),creditAssignment)
      
      end_index = -1
      missedOptimalIter = 0
      
      while(end_index == -1){
        generated_data = simulateData(trueModelData,ratdata,allModels)
        end_index = getEndIndex(generated_data@allpaths, sim=1, limit=0.95)
        missedOptimalIter=missedOptimalIter+1
        
        if(missedOptimalIter>500)
        {
          break
        }
        set.seed(NULL)
      }
      
      if(end_index > -1)
      {
        generated_data = populateSimRatModel(ratdata,generated_data,modelName)
        generated_data@simModel = trueModelData@Model
        generated_data@simMethod = trueModelData@creditAssignment
        generated_data
      }
      
    }
)

print(time1)
  
  allData<-unlist(generatedDataList)
  modelNum =  length(allData)


time2<- system.time(  
  resList<-
   foreach(i = 1:modelNum, .options.mpi=opts) %:%
    foreach(model = modelNames) %dopar% {
      generated_data = allData[[i]]
      modelName = strsplit(model,"\\.")[[1]][1]
      creditAssignment = strsplit(model,"\\.")[[1]][2]
      modelData =  new("ModelData", Model=modelName, creditAssignment = creditAssignment, sim=1)
      argList<-getArgList(modelData,generated_data)
      np.val = length(argList$lower) * 10
      myList <- DEoptim.control(NP=np.val, F=0.8, CR = 0.9,trace = FALSE, itermax = 200)
      out <-DEoptim(negLogLikFunc,argList$lower,argList$upper,ratdata=argList[[3]],half_index=argList[[4]],modelData=argList[[5]],testModel = argList[[6]],sim = argList[[7]],myList)
      modelData = setModelParams(modelData, unname(out$optim$bestmem))
      modelData = setModelResults(modelData,generated_data,allModels)
      list(data=generated_data,res=modelData)
    }
 )
  
print(time2)
  for(i in 1:modelNum)
  {
    min_method = ""
    min_lik = 100000
    gen_model = resList[[i]][[1]]$data@simModel
    gen_method = resList[[i]][[1]]$data@simMethod
    gen_modelname = paste(gen_model, gen_method, sep=".")
    
    for(m in 1:length(modelNames))
    {
      res_model = resList[[i]][[m]]$res@Model
      res_method = resList[[i]][[m]]$res@creditAssignment
      likelihood = resList[[i]][[m]]$res@likelihood
      res_modelname = paste(gen_model, gen_method, sep=".")
      
      if(likelihood < min_lik)
      {
        min_method = res_modelname
      }
      
    }
    mat_res[gen_modelname,res_modelname] = mat_res[gen_modelname,res_modelname]+1
  }
  
  rat = ratdata@rat
  save(mat_res, generatedDataList,resList,  file = paste0(rat, format(Sys.time(),'_%Y%m%d_%H%M%S'),"_mat_res.Rdata"))


  if(setup.hpc)
  {
    #stopCluster(cl)
    #stopImplicitCluster()
    closeCluster(cl)
  }
  else
  {
    stopCluster(cl)
    stopImplicitCluster()
  }

    
    #boxplotMse(mat_res,model,rat)
    
    # if(!checkValidation(mat_res,model,rat)){
    #   validated = FALSE
    #   break
    # }
    
}
  

getMinimumLikelihood=function(allmodelRes,testingdata)
{
  min_index = 0
  min = 100000
  min_method = "null"
  
  for(m in testingdata@Models)
  {
    for(crAssgn in testingdata@creditAssignment)
    {
      modelData = getModelData(allmodelRes,m,crAssgn)
      lik = modelData@likelihood
      modelName = paste(modelData@Model,modelData@creditAssignment,sep=".")
      
      #print(sprintf("model=%s,likelihood=%f",modelName,lik))
      
      if(lik < min)
      {
        min = lik
        min_method = modelName
      }
    }
  }
  return(min_method)
}

